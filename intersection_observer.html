<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <!-- https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API 참고 -->
  <!-- Intersection_Observer는 비동기적으로 변화를 감지하는 API이며, 
        어떤 요소나 부모 컨테이너 안에서나 뷰포트라는 즉 윈도우 전체 창 안에서 요소의 인터섹션을 감지한다. -->
  <!-- 만약 윈도우 창 안에 많은 페이지의 내용이 길게 들어있을 경우 사용자에게 보여주는 부분과 
        보여주지 않는 모든 요소를 DOM요소에 놔두게 되면 메모리를 많이 사용하게 된다. -->
  <!-- => 사용자에게 보여지는 부분만 DOM요소에 두고 보여지지 않는 것은 DOM에서 잠시 삭제를 했다가 
          사용자가 스크롤링 했을 때 다시 DOM요소에 등록해주는 일이 가능하다. -->
  <style>
    * {
      box-sizing: border-box;
      /* 패딩과 보더가 요소의 너비와 높이에 포함 되도록! */
    }

    .box {
      width: 300px;
      height: 300px;
      margin: 80px auto;
      background-color: plum;
      transition: 2000ms;
    }

    .box.active {
      background-color: purple;
    }
  </style>
</head>

<body>
  <div class="box">1</div>
  <div class="box">2</div>
  <div class="box">3</div>
  <div class="box">4</div>
  <div class="box">5</div>
  <div class="box">6</div>
  <div class="box">7</div>
  <div class="box">8</div>
  <div class="box">9</div>
  <div class="box">10</div>
  <div class="box">11</div>
  <div class="box">12</div>
  <div class="box">13</div>
  <div class="box">14</div>
  <div class="box">15</div>
  <div class="box">16</div>
  <div class="box">17</div>
  <div class="box">18</div>
  <div class="box">19</div>
  <div class="box">20</div>

  <script>
    const boxes = document.querySelectorAll('.box');
    // console.log(boxs);

    const options = {
      // root는 기본적으로 설정하지 않으면 null
      root: null, // 따로 루트를 명시하지 않는 이상 뷰포트가 기본적으로 사용된다.
      rootMargin: '0px', // 기본적으로 설정하지 않으면 0
      threshold: 1, // 기본값은 0이며 0 ~ 1(100%),얼마만큼 보여져야 콜백함수가 호출될지 결정하는 것
      // 들어올 때는 정해진 값이 되고 나갈 때는 즉, isIntersecting때는 threshold가 적용되고 반대의 경우에는 지정된 값에 반대가 된다.
      // 만약 0.2로 값을 정하면 0.2만큼 들어와야 보여지고 0.8만큼 나가야지 콜백함수가 수행된다. 
      // => 20%만큼 보여야지 들어올 수 있고 20%만큼 보여야지 나갈 수 있다.
    };
    const callback = (entries, observer) => {
      // console.log(entries);
      // console.log(observer);
      entries.forEach(entry => {
        // console.log(entry.target);

        // 들쑥 날쑥 확인
        if (entry.isIntersecting) {
          console.log(entry.target);
          // entry가 들어올 때는 target
          entry.target.classList.add('active');
        } else {
          console.error(entry.target);
          entry.target.classList.remove('active');
        }
      })
    };
    const observer = new IntersectionObserver(callback, options);

    // 원하는 요소가 특정한 영역에 들어왔을 때 알려주는 콜백함수를 호출해주는 관찰자이다.
    // const observer = new IntersectionObserver((entries, observer) => {
    //   console.log('observer!');
    // });
    boxes.forEach((box) => observer.observe(box));


      // 1
      // window.addEventListener('scroll', (event) => {
      //   const boxes = document.querySelectorAll('.box');
      //   boxes.forEach((box) => {
      //     const rect = box.getBoundingClientRect();
      //     // console.log('scroll');
      //     // rect중에 가장 윈도우의 중간에 근접한 요소를 찾아낼 수 있다. (또는 최상위에 있는 것을 찾을 수도 있다.)
      //     // clientRect은 요소의 크기를 얻어오기 위해 브라우저 위에 DOM 요소에 레이아웃이 발생하게 된다.
      //     // ✔ 페이지 위에서 레이아웃이 다시 발생한다는 것은 성능에 좋지 않다.
      //   });
      // });
      // 콜백 함수는 브라우저에 특정한 이벤트가 발생할 때 수행! => 메인 스레드(UI 스레드) 위에서 동작한다.
      // => 문제점: 위 코드가 실행되는 동안엔 다른 코드가 실행될 수 없으며 클릭 이벤트가 발생해도 클릭 이벤트의 핸들러가 수행되지 않는다.
      //      즉, 위 코드는 배열의 사이즈만큼 레이아웃이 다시 발생하기 때문에 성능에 좋지 않다.
      // => ✔ 이벤트에 등록되는 콜백함수는 최대한 간단하고 성능이 무겁지 않은 성능과 연관이 없는 가벼운 것들만 사용하는 것이 좋다.

      // 2
      // const boxes = document.querySelectorAll('.box');
      // const rects = boxes.forEach((box) => {
      //   const rect = box.getBoundingClientRect();
      // });
      // window.addEventListener('scroll', (event) => {
      //   rects.forEach(rect => {

      //   })
      // });
      // 위 코드의 단점: 박스 사이즈가 고정되어 있고 섹션은 브라우저에 따라 너비가 변화되면 섹션의 너비가 달라진다.
      //                이미 구해진 rect의 사이즈가 잘못 되었을 가능성이 크다!
  </script>
</body>

</html>